<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫猫和兔兔的2025年终总结</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: "Microsoft YaHei", sans-serif;
        }
        canvas {
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border-radius: 20px;
            background: #fff;
        }
        #loading {
            position: absolute; color: white; font-size: 24px; top: 40%; pointer-events: none;
        }
        #replayBtn {
            position: absolute; bottom: 30px; padding: 12px 30px;
            background: #ff6b6b; color: white; border: none; border-radius: 50px;
            font-size: 18px; cursor: pointer; display: none; z-index: 100;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        #replayBtn:hover { transform: scale(1.1); }
    </style>
</head>
<body>

<div id="loading">正在加载动画资源...</div>
<canvas id="storyCanvas"></canvas>
<button id="replayBtn">再看一次完整故事</button>

<script src="https://cdn.staticfile.org/gsap/3.12.2/gsap.min.js"></script>

<script>
    window.onload = function() {
        const loadingDiv = document.getElementById('loading');
        if (typeof gsap === 'undefined') {
            loadingDiv.innerHTML = "⚠️ 动画库加载失败，请刷新页面重试"; return;
        }
        loadingDiv.style.display = 'none';
        initStory();
    };

    const canvas = document.getElementById('storyCanvas');
    const ctx = canvas.getContext('2d');
    const replayBtn = document.getElementById('replayBtn');

    const WIDTH = 900;
    const HEIGHT = 600;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // --- 状态定义 ---
    const state = {
        bgColor: '#87CEEB', groundColor: '#7CFC00',
        mainText: "", subText: "", textOpacity: 1,
        scene: 'intro', 
        isPetting: false, pettingHandY: 0,
        butterfly: { x: -50, y: 300, visible: false },
        cat: { x: -150, y: HEIGHT - 130, color: '#808080', stripes: false, pose: 'front', expression: 'sad', scaleY: 1 },
        rabbit: { x: WIDTH + 150, y: HEIGHT - 130, pose: 'front', scaleY: 1 },
        hearts: [], fireworks: []
    };

    // --- 绘图函数 ---
    function drawEllipse(x, y, rx, ry, color, rotation=0) {
        ctx.fillStyle = color; ctx.beginPath();
        ctx.ellipse(x, y, rx, ry, rotation, 0, Math.PI*2); ctx.fill();
    }
    
    function drawCat(cat) {
        ctx.save(); ctx.translate(cat.x, cat.y); ctx.scale(1, cat.scaleY);
        const color = cat.color;
        
        if (cat.pose === 'front') {
            ctx.beginPath(); ctx.moveTo(30, 20); ctx.quadraticCurveTo(50, -10, 40, -30);
            ctx.lineWidth = 8; ctx.strokeStyle = color; ctx.lineCap = 'round'; ctx.stroke();
            drawEllipse(0, 25, 38, 30, color); drawEllipse(0, 28, 22, 20, '#FFF8DC');
            drawEllipse(0, -10, 35, 30, color);
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.moveTo(-28, -20); ctx.lineTo(-40, -55); ctx.lineTo(-10, -35); ctx.fill();
            ctx.beginPath(); ctx.moveTo(28, -20); ctx.lineTo(40, -55); ctx.lineTo(10, -35); ctx.fill();

            if (cat.expression === 'sad') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-20, -15); ctx.lineTo(-10, -10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(20, -15); ctx.lineTo(10, -10); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 5, 5, Math.PI, 0); ctx.stroke();
            } else if (cat.expression === 'sleep') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(-15, -10, 6, 0, Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.arc(15, -10, 6, 0, Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 5, 3, 0, Math.PI); ctx.stroke();
            } else if (cat.expression === 'enjoy') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(-15, -10, 6, 0.1*Math.PI, 0.9*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.arc(15, -10, 6, 0.1*Math.PI, 0.9*Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-3,3); ctx.moveTo(0,0); ctx.lineTo(3,3); ctx.stroke();
                drawEllipse(-25, 0, 6, 4, 'rgba(255,100,100,0.3)'); drawEllipse(25, 0, 6, 4, 'rgba(255,100,100,0.3)');
            } else { 
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(-12, -12, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(12, -12, 4, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-3,3); ctx.moveTo(0,0); ctx.lineTo(3,3); ctx.stroke();
            }
            ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
            ctx.beginPath(); 
            ctx.moveTo(-20, 0); ctx.lineTo(-45, -5); ctx.moveTo(-20, 5); ctx.lineTo(-45, 10);
            ctx.moveTo(20, 0); ctx.lineTo(45, -5); ctx.moveTo(20, 5); ctx.lineTo(45, 10);
            ctx.stroke();

        } else if (cat.pose === 'side_right') {
            drawEllipse(-10, 25, 25, 30, color, -0.2); 
            ctx.beginPath(); ctx.moveTo(-30, 20); ctx.quadraticCurveTo(-50, 0, -40, -30); 
            ctx.lineWidth = 8; ctx.strokeStyle = color; ctx.stroke();
            ctx.beginPath(); ctx.arc(10, -10, 30, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.moveTo(0, -35); ctx.lineTo(15, -60); ctx.lineTo(25, -35); ctx.fill(); 
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(20, -15, 6, 0.2*Math.PI, 0.8*Math.PI); ctx.stroke();
            ctx.fillStyle = '#FF9999'; ctx.beginPath(); ctx.arc(38, -5, 3, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }

    function drawRabbit(rab) {
        ctx.save(); ctx.translate(rab.x, rab.y); ctx.scale(1, rab.scaleY);
        const color = '#FFFFFF';
        if (rab.pose === 'front') {
            drawEllipse(0, 25, 32, 35, color); drawEllipse(0, -15, 34, 32, color);
            drawEllipse(-15, -60, 9, 38, color, -0.1); drawEllipse(-15, -60, 5, 28, '#FFB6C1', -0.1);
            drawEllipse(15, -60, 9, 38, color, 0.1); drawEllipse(15, -60, 5, 28, '#FFB6C1', 0.1);

            if (state.cat.expression === 'sleep' && state.scene === 'sleeping') {
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(-10, -15, 4, 0, Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.arc(10, -15, 4, 0, Math.PI); ctx.stroke();
            } else {
                ctx.fillStyle = '#000';
                ctx.beginPath(); ctx.arc(-10, -15, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(10, -15, 4, 0, Math.PI*2); ctx.fill();
            }
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-3, 0); ctx.moveTo(0, -5); ctx.lineTo(3, 0); ctx.stroke();

            if (state.isPetting) {
                const handX = -50; const handY = 10 + state.pettingHandY; 
                ctx.strokeStyle = color; ctx.lineWidth = 12; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(-20, 10); ctx.quadraticCurveTo(-35, 10, handX, handY); ctx.stroke();
                drawEllipse(handX, handY, 10, 10, color);
            }

        } else if (rab.pose === 'side_left') {
            drawEllipse(10, 25, 28, 32, color, 0.2); 
            ctx.beginPath(); ctx.arc(35, 35, 8, 0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.arc(-10, -15, 32, 0, Math.PI*2); ctx.fill(); 
            drawEllipse(5, -60, 9, 38, color, 0.2); drawEllipse(5, -60, 5, 28, '#FFB6C1', 0.2);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.arc(-20, -18, 6, 0.2*Math.PI, 0.8*Math.PI); ctx.stroke();
            ctx.fillStyle = '#FFB6C1'; ctx.beginPath(); ctx.arc(-40, -8, 3, 0, Math.PI*2); ctx.fill(); 
        }
        ctx.restore();
    }

    // --- 背景道具 (在角色后面) ---
    function drawBackProps() {
        const mx = WIDTH/2; const fy = HEIGHT - 130;
        if (state.scene === 'reading') {
            ctx.fillStyle = '#8B4513'; ctx.fillRect(mx-100, fy+20, 200, 10);
            ctx.fillStyle = '#DEB887'; ctx.beginPath(); ctx.ellipse(mx, fy+20, 110, 20, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.fillRect(mx-15, fy, 30, 20);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(mx-15, fy, 30, 20);
        }
        else if (state.scene === 'sleeping') {
            ctx.fillStyle = '#FFB6C1'; ctx.beginPath(); ctx.roundRect(mx-110, fy-20, 220, 60, 10); ctx.fill();
            ctx.fillStyle = '#FFF'; 
            ctx.beginPath(); ctx.roundRect(mx-90, fy-30, 50, 20, 5); ctx.fill();
            ctx.beginPath(); ctx.roundRect(mx+40, fy-30, 50, 20, 5); ctx.fill();
        }
    }
    
    // --- 前景道具 (在角色前面：被子、食物) ---
    function drawForeProps() {
        const mx = WIDTH/2; const fy = HEIGHT - 130;
        
        // 修复点：吃饭的道具移到这里，确保在最上层
        if (state.scene === 'eating') {
            // 猫碗 & 鱼
            ctx.fillStyle = '#E0E0E0'; ctx.beginPath(); ctx.arc(mx-70, fy+35, 22, 0, Math.PI, false); ctx.fill();
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath(); ctx.ellipse(mx-70, fy+33, 15, 8, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(mx-85, fy+33); ctx.lineTo(mx-95, fy+25); ctx.lineTo(mx-95, fy+41); ctx.fill();

            // 兔碗 & 萝卜
            ctx.fillStyle = '#E0E0E0'; ctx.beginPath(); ctx.arc(mx+70, fy+35, 22, 0, Math.PI, false); ctx.fill();
            ctx.fillStyle = '#FF4500';
            ctx.beginPath(); ctx.moveTo(mx+60, fy+30); ctx.lineTo(mx+85, fy+35); ctx.lineTo(mx+60, fy+40); ctx.fill();
            ctx.fillStyle = '#228B22';
            ctx.beginPath(); ctx.moveTo(mx+85, fy+35); ctx.lineTo(mx+95, fy+30); ctx.lineTo(mx+95, fy+40); ctx.fill();
        }

        if (state.scene === 'sleeping') {
             const blanketY = fy + 25;
             ctx.fillStyle = 'rgba(255, 240, 245, 0.95)';
             ctx.beginPath(); ctx.roundRect(mx-110, blanketY, 220, 50, 8); ctx.fill();
        }
    }

    function drawButterfly() {
        if (!state.butterfly.visible) return;
        const {x, y} = state.butterfly;
        ctx.save(); ctx.translate(x, y);
        const wingScale = Math.sin(Date.now() / 50);
        ctx.scale(wingScale, 1); 
        ctx.fillStyle = '#FFD700';
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-15, -15); ctx.lineTo(-15, 15); ctx.fill();
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(15, -15); ctx.lineTo(15, 15); ctx.fill();
        ctx.restore();
    }

    function drawSceneBackground() {
        ctx.fillStyle = state.bgColor; ctx.fillRect(0,0,WIDTH,HEIGHT);
        
        if (['care', 'eating', 'reading', 'sleeping'].includes(state.scene)) {
            ctx.fillStyle = '#FFDEAD'; ctx.fillRect(0, HEIGHT-100, WIDTH, 100);
            ctx.fillStyle = '#FFF'; ctx.fillRect(100, 100, 150, 150);
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(110, 110, 60, 60); ctx.fillRect(180, 110, 60, 60);
            ctx.fillRect(110, 180, 60, 60); ctx.fillRect(180, 180, 60, 60);
        } else if (state.scene === 'night' || state.scene === 'kiss') {
            ctx.fillStyle = '#2F4F4F'; ctx.fillRect(0, HEIGHT-100, WIDTH, 100);
        } else {
            ctx.fillStyle = state.groundColor; ctx.fillRect(0, HEIGHT-100, WIDTH, 100);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            drawEllipse(200, 100, 50, 30, 'rgba(255,255,255,0.6)');
            drawEllipse(600, 80, 60, 35, 'rgba(255,255,255,0.6)');
        }
    }

    class Firework {
        constructor(x, y) {
            this.x = x; this.y = y; this.age = 0; this.particles = [];
            const colors = ['#FF0000', '#00FF00', '#00BFFF', '#FFD700', '#FF1493'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            for(let i=0; i<40; i++) {
                const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 6;
                this.particles.push({ vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, x: 0, y: 0, color: color });
            }
        }
        update() { this.age++; this.particles.forEach(p => { p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; }); }
        draw(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = 1 - this.age/60;
            this.particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); });
            ctx.restore();
        }
    }

    function spawnHeart(x, y) { state.hearts.push({x, y, alpha: 1}); }

    // --- 主循环 ---
    function animate() {
        ctx.clearRect(0,0,WIDTH,HEIGHT);
        drawSceneBackground();
        drawButterfly();
        drawBackProps(); // 背景道具 (桌子、床架)

        ctx.globalAlpha = state.textOpacity;
        ctx.fillStyle = (state.scene === 'night' || state.scene === 'kiss') ? '#FFF' : '#555';
        ctx.textAlign = 'center';
        ctx.font = 'bold 32px "Microsoft YaHei"';
        ctx.fillText(state.mainText, WIDTH/2, 70);
        ctx.font = '22px "Microsoft YaHei"';
        ctx.fillText(state.subText, WIDTH/2, 110);
        ctx.globalAlpha = 1;

        drawCat(state.cat);
        drawRabbit(state.rabbit);
        drawForeProps(); // 前景道具 (食物、被子) - 确保在最前面

        state.hearts.forEach((h, i) => {
            h.y -= 1; h.alpha -= 0.02;
            ctx.save(); ctx.globalAlpha = Math.max(0, h.alpha); ctx.fillStyle = '#FF69B4';
            ctx.translate(h.x, h.y);
            ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(-10,-10,-20,5,0,15); ctx.bezierCurveTo(20,5,10,-10,0,0); ctx.fill();
            ctx.restore();
            if(h.alpha<=0) state.hearts.splice(i,1);
        });

        state.fireworks.forEach((fw, i) => {
            fw.update(); fw.draw(ctx);
            if(fw.age > 60) state.fireworks.splice(i,1);
        });
        if(state.scene === 'kiss' && Math.random() < 0.05) {
            state.fireworks.push(new Firework(Math.random()*WIDTH, Math.random()*HEIGHT/2));
        }

        requestAnimationFrame(animate);
    }

    let mainTimeline;

    function initStory() {
        animate();
        startTimeline();
        replayBtn.onclick = startTimeline;
    }

    function startTimeline() {
        if(mainTimeline) mainTimeline.kill();
        state.scene = 'intro';
        state.cat.x = -150; state.cat.color = '#808080'; state.cat.expression = 'sad'; state.cat.pose = 'front';
        state.rabbit.x = WIDTH+150; state.rabbit.pose = 'front'; state.isPetting = false;
        state.butterfly.visible = false; state.hearts = []; state.fireworks = [];
        state.bgColor = '#87CEEB'; 
        replayBtn.style.display = 'none';

        const tl = gsap.timeline();
        mainTimeline = tl;
        const midX = WIDTH/2;
        const floorY = HEIGHT - 130;

        // 1. 相遇
        tl.set(state, { mainText: "小流浪猫猫，孤单又无助...", subText: "" })
          .to(state.cat, { x: midX - 80, duration: 2.5, ease: "power1.out" })
          .set(state, { mainText: "温柔的兔兔发现了它！" })
          .to(state.rabbit, { x: midX + 80, duration: 2, ease: "power1.out" });

        // 2. 带回家 & 摸摸头
        tl.to(state, { textOpacity: 0 }, "+=1")
          .set(state, { scene: 'care', bgColor: '#FFFAF0', mainText: "兔兔把猫猫带回家", subText: "轻轻地摸摸头..." })
          .to(state, { textOpacity: 1 })
          .to(state.cat, { x: midX - 60, y: floorY }, "<") 
          .to(state.rabbit, { x: midX + 20, y: floorY }, "<")
          .set(state, { isPetting: true })
          .to(state.cat, { expression: 'enjoy' }, "<")
          .to(state, { pettingHandY: -15, duration: 0.5, yoyo: true, repeat: 3, ease: "sine.inOut" })
          .call(() => spawnHeart(midX-60, floorY-60))
          .set(state, { isPetting: false })
          .to(state.cat, { color: '#FFA500', expression: 'happy', stripes: true, duration: 1 }) 
          .set(state, { subText: "猫猫变干净了！" });

        // 3. 吃饭 (鱼和胡萝卜)
        tl.to(state, { textOpacity: 0 }, "+=1")
          .set(state, { scene: 'eating', mainText: "一起吃饭", subText: "猫猫吃鱼，兔兔吃胡萝卜" })
          .to(state, { textOpacity: 1 })
          .to(state.cat, { x: midX - 80, y: floorY }, "<") 
          .to(state.rabbit, { x: midX + 80, y: floorY }, "<")
          .to([state.cat, state.rabbit], { y: floorY+10, yoyo: true, repeat: 3, duration: 0.3 });

        // 4. 看书
        tl.to(state, { textOpacity: 0 }, "+=0.5")
          .set(state, { scene: 'reading', mainText: "一起看书学习", subText: "安静的午后时光" })
          .to(state, { textOpacity: 1 })
          .to(state.cat, { x: midX - 50, y: floorY }, "<") 
          .to(state.rabbit, { x: midX + 50, y: floorY }, "<");

        // 5. 睡觉 (露脸)
        tl.to(state, { textOpacity: 0 }, "+=1.5")
          .set(state, { scene: 'sleeping', mainText: "一起睡觉觉", subText: "暖暖的被窝，露出小脑袋", 'cat.expression': 'sleep' })
          .to(state, { textOpacity: 1 })
          .to(state.cat, { x: midX - 45, y: floorY+10 }, "<") 
          .to(state.rabbit, { x: midX + 45, y: floorY+10 }, "<");

        // 6. 户外玩耍
        tl.to(state, { textOpacity: 0 }, "+=2")
          .set(state, { scene: 'play', bgColor: '#87CEEB', mainText: "天气好，出去追蝴蝶！", subText: "", 'cat.expression': 'happy' })
          .to(state, { textOpacity: 1 })
          .set(state.butterfly, { visible: true, x: midX, y: floorY - 100 })
          .to(state.butterfly, { x: WIDTH, y: floorY - 150, duration: 3, ease: "linear" }, "play")
          .to(state.rabbit, { x: WIDTH-100, duration: 2.5, ease: "power1.inOut" }, "play")
          .to(state.rabbit, { y: floorY - 40, duration: 0.3, yoyo: true, repeat: 3 }, "play")
          .to(state.cat, { x: WIDTH-160, duration: 2.8, ease: "power1.inOut" }, "play")
          .to(state.cat, { y: floorY - 30, duration: 0.3, yoyo: true, repeat: 3, delay: 0.2 }, "play");

        // 7. 2025跨年 (侧面亲亲)
        tl.to(state, { textOpacity: 0 }, "+=0.5")
          .set(state.butterfly, { visible: false })
          .set(state, { scene: 'night', bgColor: '#191970', mainText: "2025年的最后一刻...", subText: "准备好了吗？" })
          .set(state.cat, { x: midX - 60, y: floorY })
          .set(state.rabbit, { x: midX + 60, y: floorY })
          .to(state, { textOpacity: 1 })
          .set(state.cat, { pose: 'side_right' })
          .set(state.rabbit, { pose: 'side_left' })
          .to(state.cat, { x: midX - 45, duration: 1 })
          .to(state.rabbit, { x: midX + 45, duration: 1 }, "<")
          .set(state, { scene: 'kiss', mainText: "✨ 2026 新年快乐！✨", subText: "兔兔有猫猫，猫猫有兔兔了yeah。" })
          .call(() => spawnHeart(midX, floorY - 60))
          .call(() => { replayBtn.style.display = 'block'; }, null, "+=5");
    }
</script>
</body>
</html>
